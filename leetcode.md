# leecode

#### 参赛

心理素质还不够好、过度化问题

先转移方程再写程序

应用调试方法对比程序区别

#### [探索 初级算法 内容记录](https://leetcode-cn.com/explore/interview/card/top-interview-questions-easy/)

* 数组：26, 189, 136, 350, 1
* 字符串：344, 387
* 链表：21, 206, 141
* 二叉树：104, 98
* 问题：探索中接口设计问题未做

#### 1 两数之和

头回见到hashmap的题

#### 2 链表数相加

没有考虑最后一位进位的情况

#### 3 无重复字符的最长子串

出错

* 清空后未加入
* dvdf串问题

#### 6 Z 字形变换

特殊值零长度，宽度计算不明确

#### 10 正则表达式匹配

问题：照着写的

#### 15 三数之和

后部分面多了加水算法。视频课中算法

#### 18 四数之和

避免重复是关键，在此处出错两次，一次是2的情况，一次是n的情况。

#### 19 删除链表倒数第N个

如果前指针在执行while之前已经为空，则引发新情况。现在的优化可能还有提升空间。不到三天，我已经完全忘了这道题怎么做…

#### 21 合并两个有序链表

有序是指升序。 注意两个表中某个表为空的问题，当前代码可能还可以优化。

#### 22

问题：未仔细思考

#### 23

问题：优化

#### 26 移除有序数组中的重复值

优化了一波时间反而变慢了，时间统计可能有问题。

#### 28 实现strStr()

未考虑串与子串相同的情况
这道题三天还没有做出来。很慌。
问题：[KMP](http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html)

#### 32 最长有效括号

动态规划思考方向错误

#### 33

二分查找：可在m刚计算完就试图返回值。

在m不是target的前提下，左右标记移动会更加方便。将m为target单独划分为一类。选择这种正确的划分问题方式，能大大简化解法。

#### 34 在排序数组中查找元素的第一个和最后一个位置

``` 
prel  l   m   r   prer    |
  >   >                   |l=m,repl=l
  >   <                   |l=l&prel aver
              <   <       |r=m,prer=r
              >   <       |r=r&prer aver
```

方法：二分法要注意左等于中，右等于左加一的情况

二分法要特别注意：n和n+1的平均数是n

#### 35 搜索插入位置

特殊情况：列表为空
正常情况下解的类型：0, n
二分法演变结果，肯定会经过l+1=r的状态

#### 37 解数独

优化方法

* 预处理可选
* 可能性排序

#### 41 缺失的第一个正数

根据数组长度，答案是有范围的。
在不改变元素的本身信息的前提下，用正负来存储是否出现的信息。

#### 46 全排列生成

[reduce的使用](https://leetcode.com/problems/permutations/discuss/18241/One-Liners-in-Python)

#### 49 字母异位词分组

放弃原因自己答案的原因：列表和字典不能作为键，这种设定可能是因为其元素轻易能改变，会导致混乱。我也理解了元组为什么是必要的。

看到其他答案中排序后用字典统计。想到了这种做法是否是异位词的简单做法。虽然是简单做法，应用到这题里效率会高。

#### 50 Pow(x, n)

这道题分治法答案比我写的要简洁得多：实际并不需要字典存储中间值，将中间值作为新的x传入函数即可。

非递归法中的位运算也很值得学习。

#### 52 N皇后问题二进制版

a&-a：取最后一个1（反码）
a&a-1：去掉最后一个1

#### 53 最大子序和

问题：分治解法
这道题难度竟然也是简单。默认解法是穷举法吗？

不可先合并再计算，全负数序列无法通过。

最开始我觉得需要这道题需要记录三个量：
*第i个之前最大连续子序和（不必须包括i-1）
*上数是否包含第i-1个数
*以i-1为结尾的最大和

后来在实现的时候，觉得第二个判定的逻辑比较复杂。而且第一个数的开始位置未知，想不出来如何实现
现在把这个想法写出来，发现判定第一个和第三个是否相等就根本不用存第二个量。

所以就在网上找答案了。动态规划法利用了最大序列和的以下特点：第一个数不会是是负数，同理得出，该序列的任一个开头位置与其相同的子序列也不为负数。有了这个重要的特点，就的出了需要记录的状态：
1.i-1为结尾的最大子序列和sum

1. 历史最大子序列和maxsum

步骤如下：

1. 若sum<0, 则sum=curr（利用之前说的重要的特点）。否则sum+=curr。
1. 若sum>maxsum，maxsum=sum

由于 重要的特点 ，sum将是一直正确的：如果前一个sum>0，则curr累加即可。否则说明前面的应该抛弃，不放在最优子序列里。

#### 54

极端值找了很多次，一个完美的解法事很难写出来的

#### 69

不能用搜索第一个小于等于值的原因是，如果r先占了答案位置，则l无法向r进。

#### 70 爬楼梯

未考虑台阶总数为1，2时。

#### 79 单词搜索

DFS解决
1：没有出路的字符板
2：最后一个数字往返问题
3：效率优化，所有格全计算
4：得到正确结果后放弃未计算部分

#### 82 链表重复全删

链表方法：
想明白再写。
需要写后续步骤和特殊情况，想到就马上加。
步骤细节加注释。

#### 83 移除有序链表中的重复值

问题的核心是如何避免访问空指针。 当前节点不为空，保障的是的是顺序下行（此外还有传入值为空表的情况） 当前节点的下节点不为空，保障的是删除节点，如果下节点为空则会异常访问无法比较。

#### 84 翻车现场

与黄金问题相比，此问题的

* 最优子结构：

三种选一，三种分别为：最小值左侧所有的最优解，最小值右侧的最优解，最小值乘范围宽度

* 状态转移公式：

min=min(n, m)
f(n, m)=max(  a(n-m)  , f )

* 边界：

当n=m时，面积为1

递归解法超时，Python在做某些事的时候棘手。遍历特定范围元素值的时候容易搞错，容易混乱。

解决了混乱的python代码仍超时，可能是因为重复计算边界的原因。

混乱解决了依旧超时，也许需要用非递归计算。网上找了个答案依旧超时。非递归朴素算法超时。朴素解法、递归解法都会超时，想不到其他办法了，换语言了。
java递归成功，但成绩不好，排名靠前的有优化。用python写算法可能不是个正确的选择…

方法：

* 如何通过一维的想到二维（85）的解法。
* 思路：先想暴力法，计算过程中，观察题目的特点。
* 递归边界值处理的问题：如果后边界下标的值就是最小值，会出现因前后下标相等产生的数组越界问题。

以后要注意，后边界下标和前边界下标被包括应当相同。不然越界。

lt高效解法阅读：
左大于右、左右相等情况返回值处理。
记录是否是升序。记录最小值下标。
记录升序原因：升序可以用当前值表示当前到最有最大面积

2018年11月9日 对高效算法的分析
优化内容：
问题：为什么检测升序能提高这么多性能？
可能和升序区域使用穷举法遍历效率高有关。

#### 85 最大矩形

给出的数据需要更改。为了方便查询，应当将非零数改为此位置逆扫描方向有多少个数。

#### 93 IP地址复原

这道题最开始想用搜索做，但是很难写。于是试着列出所有解法，结果发现穷举法是很好的。于是使用了穷举法。

这道题告诉我们，碰到一道题应该先把所有解法列出来，从时间复杂度和实现难度中综合考虑。

#### 94 树的中序遍历

递归转非递归程序需要主义，非递归程序的当前运行层、运行结构应当仿照递归程序。而非直接写，直接写比较困难。
问题：不熟练，需要重写

#### 98 验证二叉搜索树

中序遍历，只要一直比前一个节点大即为。

未考虑到子树中的最大值最小值。
这道题的优秀解法都没用到hashmap。
问题：看懂优秀解法，尤其是栈实现的。

#### 102 二叉树的层次遍历

深度遍历和广度遍历实现

#### 120 三角形最小路径和

* 从底向下运算容易列出状态转移方程。
* 可用同一个数组存储，因为同位置数据之后不需要了。

#### 123

问题：优化

#### 138 复制带随机指针的链表

问题的关键是复制后，之间的关系需要相同

#### 139 单词拆分

dfs记忆化和动态规划

#### 141 检测链表中的环

方法：在有两种返回值的情况下，如果默认返回值就是包含为空或者仅一个输入之类特殊值的返回值，会使判断逻辑更简单。

#### 142 环形链表中成环部分检测

最容易的是，哈希表实现存储已经过的点。
如果不用额外空间
环形检测是用快慢指针解决
环的特点是交叉路口
环形部分和直线部分
直线部分的尾部指向即为解
问题：为什么从0计数是正确的？因为边界点重复计算。
这个问题很危险，如果考试的时候纠结太长时间肯定就凉了。
方法：观察相似问题的解法

#### 146

问题：照着写的

#### 149
该方法无法识别差值为小数的两点构成的直线

#### 150

错误出现：给出的是数字，而不是字符串
未自定义用例就提交
//与int(/)不相同

#### 152 乘积最大的子序列

元素分三种：正数、负数、0。
正数则区域性累乘
0则中断序列
连续偶数个负数相当于正数。
连续奇数个负数最复杂。相当于两个不定区：正负或负正。简便起见，将其分为负负负三个区。单个负数算为-1、本身、-1
方案：简化过程略。简化后，负区为偶数个直接相乘即可，负区为奇数个的区域需要规划。
最优子结构：
边界：
状态转移方程：
觉得这道题用n方的优化穷举法做比较好。但是看了课之后才发现DP是n的，因为其可以利用使用存储空间保存之前计算的结果。
代码内有两次错误的说明

#### 153 寻找旋转排序数组中的最小值/顺序移动过的有序数组中的最小值

``` 
特殊情况：len(nums)为零,sloved
l m r     |
 < <      |上坡，最高点已被错过，和上一步有关
 > <      |min is between l&m.r replace by m.if m is not mid, r=mid-1.else return mid
 < >      |min is between m&r.l replcae by m.if m is not mid, l=mid+1.else return mid
 > >      |不存在

l m r     |
base > <
 =        |l,m is min
   =      |l,r,m is min same
 = =      |same as upon
base < >
 =        |r is min
   =      |r,l,m is min same
 = =      |same as upon
```

0答非所问：题目要求值，我给的是编号。
方法：先把题意写草稿。

2018年11月8日1死循环：未考虑l，r命中min的情况，min偏1赋给l或r不科学：m确定了不是最小的，却把m偏1这个未知的给出去。

2018年11月9日2死循环：未考虑极端值全升序。
方法：将特殊值写道草稿首。

#### 169 求众数

解法的特点

* map需要存储空间
* 排序需要改动数据
* 分治鲁棒性不强

问题：递归和位运算解法

#### 212

问题：照着写的

#### 236 二叉树的最近公共祖先

非递归解法难以追踪历史层级。
2019年1月4日
这道题最开始我想非递归、记录历史轨迹实现，但尝试几次之后因为历史轨迹记录实现困难放弃了，改用递归实现。此时我认为递归实现，也是需要记录轨迹的。这走进了一个误区：认为必须将两个节点的所有祖先列出才能求交集。实际上不是这样。看到答案的思路后，发现公共祖先的特征十分明显，易于判断。

如何列出某节点的所有祖先？

看到深度优先搜索的讲解，发现于我在这道题碰到的问题相同。

三种解法：递归、记录父节点、栈记录路径.

#### 240 搜索二叉树组2

#### 300

问题：优化

[解法](https://leetcode.com/problems/longest-increasing-subsequence/discuss/74824/JavaPython-Binary-search-O(nlogn)-time-with-explanation)

[官方解，最后一个是最优](https://leetcode.com/articles/longest-increasing-subsequence/)

解法思路：使用dp数组同时存储 当前最优解的长度 和 未来可能最优解的前半部分

#### 344 反转字符串

https://www.cnblogs.com/JohnTsai/p/5606719.html

#### 350 两个数组的交集2

hashmap实现。记录其出现次数。
探索 数组
如果是排序过的，则类似两个排序链表的合并。
若其中一个的数目远大于另一个，将小的存为哈希表，键值对为值，次数。大的存新哈希表，如果小哈希表中有再建立数据。统计个数。
hash表

#### 354 套娃信封

一二参数顺序相反是为了构成最长上升子序列

#### 374 猜数字

要注意mid在相加除二过程中的溢出问题。

#### 338 数字对应二进制1个数的统计

在结果基础上加一，但在什么位置就不用管了

#### 402 移除k位数字

先转数字再转字符串是为了去除前置零

#### 547 朋友圈的个数

并查集合并时为什么不能是root[p]=root[q]?

因为不是两个集合的合并，而是两个元素的合并

问题：547的其他解法

#### 622 设计循环队列

题目中提到了不正常返回-1，但我没仔细看。
未仔细思考添加、删除操作，具体操作是什么。
头尾相遇时是特殊操作，与一般的出队列不同？错误。相同。
我还是没搞清楚头尾变量分别是什么

#### 692 前K个高频单词

自己的想法发现太复杂，放弃，看答案。

官方答案python：

* 怎么实现字典排序

``` 
list.sort(key=lambda w:(w[a],w[b]))
```

可实现_a相同时，按_b排序。

sort函数对元组值(x, y)比较时，x相等则根据y排序

#### 695

因为 坐标值表示、用坐标值生成的代码表示 混用，弄得代码很混乱，最后决定放弃重写。血泪的教训以后只用一种通用表达方式。

#### 1042 不邻接植花

不同的填色方案是等价的，所以不需要dfs。只需要朴素即可得出正确答案。

