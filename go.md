## [Go语言从入门到实战](https://time.geekbang.org/course/intro/160)

#### 04 

应用入口文件名不一定是main.go， 必须package main、 func main。 

main函数不支持返回值， 使用os.exit()返回。 

main函数不支持参数传入， 使用os. Args读取参数

#### 05

测试程序格式： **源码文件**以_test结尾， 测试方法以Test开头： func TestXXX(t *testing. T){…}

大写开头包外可访问。 

#### 06

类型间， 类型与其别名间不可隐式转换。 

#### 07 数组和切片

len和cap。数组间可比较。位操作符 &^ 按位清零。

#### 12

string类型内容不可更改， len存放的是byte数， 且string可存放任何二进制数据。 占位符"%[下标]x", 数组。 

#### 13 函数

函数多返回值，所有参数均是值传递，函数可以作为变量的值，函数可以作为参数和返回值。

函数嵌套计时例子

#### 14

函数不定长， defer延迟执行

#### 15

行为（结构体的方法）定义时参数为结构体地址， 则不会复制， 为结构体本身， 则会复制

#### 16

无继承， 非入侵性实现接口， ducktype方式， 循环依赖， 实现单向

#### 17

重载严格， 不支持lsp， 重载

#### 18

接口最佳实践： 最小接口

#### 19

错误处理最佳实践： 及早失败， 若发生错误则返回错误信息并return， 若没错则继续执行， 避免try的嵌套

#### 20

panic不可恢复错误， 退出前会执行defer内容。 Os.exit不会调用defer， 不输出当前调用栈信息。 recover修复错误。 错误的方法： 只记录， 不做任何恢复。 可能导致系统明明用完资源却继续运行。 不确定时重启也是不错的。 

#### 21

首字母大写表示代表包外可访问。 package可与所在目录不一致。 同一目录go代码的package要一致。 路径的src是自带的， 调用时不用输。 依赖的包的init方法在main执行前都会被执行， 按照包导入的依赖顺序， 每个包， 每个源文件可以有多个init函数。 将依次执行。 可以导入网上的包。 Go get。 GitHub上提交不要有src

#### 22 vendor路径

解决两个问题： 同一环境不同项目无法使用同一包的不同版本； 无法管理包对特定版本的依赖。 

#### 23 协程

初始化栈仅2k， 和内核对象的对应关系是m:n多对多。 go协程处理器P在系统线程M中， 依次运行协程G队列。 守护线程会对P完成协程数计数， 若不动， 则在P任务栈中加入特别标记。 P遇到非内联函数会读到标记， 并将当前协程G放到队尾。 协程G被系统中断（如IO）时， P会将自己移到另一个M中， 继续执行自己的G队列（必须同一进程内的不同线程？ ）。 唤醒时， G会加入某个P的队列， 或者加入全局队列（是否涉及内存数据的复制？ ）。 被中断时， P在寄存器里的运行信息， 也会保存到P对象里， 当再次获得执行机会时， 会恢复现场。 

协程中执行： go关键字空格函数。 注意函数中不应访问非线程安全资源。 方法调用都是值传递。 

#### 24 共享内存并发

sync. Mutex 锁。sync. Waitgroup 等待。rwlock 读写锁。

#### 25 csp并发机制

通道完成同步。与actor model比较，松耦合channel有容量，接收程序主动处理。返回值是channel，实现异步返回。

#### 26 select多路选择实现超时退出

同时等待多个阻塞事件，顺序无关。<-time. After()。慢响应比快失败要严重

#### 27 channel的关闭和广播

关闭后返回类型默认值和false。向关闭的channel发送数据，会panic

#### 28 使用channel和select实现关闭多个消费者

close()是广播机制

#### 29 context结束关联任务

#### 30 sync.once保证只执行一次

#### 31

channel实现得到任意任务完成后得结果， 并使用buffer防止协程泄漏

#### 32

channel csp机制实现得到所有任务完成结果

#### 33 buffered channel实现对象池

#### 34

sync.pool对象缓存 GC即会将其清空 线程安全  ？ 没看懂

#### 35 单元测试

fail t.error不终止, failnow t.fatal终止。 下载后使用断言。 

#### 36 性能测试

Benchmark开头， testing.b

#### 37 BDD面向行为开发

import(."XX")里的点 代表直接调用不用包命

#### 38 反射

获取类型， 获取值， 按名字调用方法 struct tag `json:"name"` namefield.tag.get

#### 39 万能程序

reflect.deepequal Elem() 获取指针指向的值

#### 40 不安全 unsafe

一般用在c程序交互 atomic.storepointer写完后将读指针更改

#### 41 pipe-filter架构

#### 42 微内核模式 ？ 没看懂

#### 43 内置json解析 反射 方便 性能不高

#### 44 easyjson 更高性能的解析

#### 45 HTTP服务

#### 46 restful服务

#### 47 性能分析工具

输出prof文件 go tool分析； http/pprof使用HTTP输出查看即时性能分析

#### 48 性能调优过程演示

#### 49 锁对性能的影响

读写锁rwlock消耗大， sync.map写成本高， concurrentmap读写性能好。 三者的比较。 disruptor高性能数据交换队列。 

#### 50 GC友好的代码： 与javagc机制不同， 但gc友好代码差不多。 

避免内存分配和复制： 

* go全面采用值传递， 复杂对象应当传引用。 

查看gc日志的方法
go test -trace=trace_val.out
内存gc记录

* 初始化至合适大小， 复用内存

#### 51 高效字符串连接： 

占位符替换 >
+= >
byte.buffer 略大于
stringbuilder

#### 52 分布式 高可用 面向错误的设计。 

* 隔离错误， 微服务模式， 降级可用。 
* 隔离与重用， 同样的程序运行多个， 每个只接待较少的上下级。 
* 冗余， 要避免单点失效系统崩溃。 
* 限流

* 慢响应： 应该给阻塞操作加期限
* 错误向依赖的服务传递： 使用断路器， 通常配合服务降级完成

#### 53 面向恢复的设计： 预知所有失败是不可能的。 

健康检查： 注意僵尸进程， 池化资源耗尽， 死锁

未知错误应直接关闭服务， 避免成为僵尸进程

构建可恢复系统： 
拒绝单体系统， 使用微内核系统。 

面向错误和恢复的设计： 依赖服务不可用时， 可以继续存活。 快速启动。 无状态。 

与客户端协商

#### 54 混沌工程： 可控范围内模拟错误， 观察后果， 思考解决方案， 改善系统。 

主机掉线。 不返回。 返回错误。 

原则

开源实现： Netflix。 类spring框架。 

## [Go语言核心36讲](https://time.geekbang.org/column/112)

#### 1 gopath

goroot安装，gopath工作区，gobin生成可执行。

代码组织方式：目录与包对应。代码包导入路径：gopath的src下。源码文件安装位置：某个工作区的src下，pkg归档文件.a，bin可执行文件。归档文件与代码包同名，与文件夹同级。pkg下有平台相关文件夹。

#### 2 命令源码文件
独立程序入口，属于main包，包含无参数无结果的main函数。可go run运行可参数。main结束意味着程序结束。

flag接收参数

#### 3 库源码文件
供其他程序调用的程序

构建结果文件名与其父目录名称一致

导入包用文件夹名，但要as包名

internal模块级私有

#### 4 程序实体
变量声明。
代码块内:=部分重声明。

5 作用域

6 类型检查name.(type) 类型转化 类型别名

#### 7 数组和切片

数组结构体值类型，切片通道字典函数是引用类型。

切片生成扩容缩容。

#### 8 container/list和ring
list双向链表，element链表中元素。

list不接受外部element，延迟初始化。

ring循环链表和list的区别：实际都是循环链表。list由element实现，ring自己。ring代表一个元素，list代表整个。ring可以指定元素数。

len(ring)On

#### 9 map的操作和约束
哈希桶，不允许不支持等于的类型做键，键比较。

nil字典除添加外都会正常进行

并发不安全

#### 10 通道
通过复制进入和离开通道。会panic：收发关闭已关闭的chan。chan内复制的是浅复制

11 单向通道 select
select某case中chan关闭以后永不进入方式：将chan置为nil
跳出select外部的for方法：break加标签，goto

#### 12 函数
一等公民：可用于传递、赋值、判断和转换。

鉴别一个函数，函数签名。闭包，部分逻辑动态生成。

#### 13 结构体
没有继承的概念，嵌入字段实现了类型之间的组合。屏蔽现象

值方法和指针方法

可，注意其值默认未空。空结构体，代表任意结构体均能放置于该位置。

#### 14 接口类型
接口动态值，动态类型，静态类型。接口变量赋值后效果。

#### 15 指针
取指操作，不可取指的对象

#### 16 go语句和其执行规则
go语句，写成Goroutine 中介Processor 线程Machine。

go是启用G，有复用

主G结束会同时结束子G

17 等待所有协程完毕waitgroup。指定顺序运行

#### 18 if for switch

#### 19 错误处理
20

#### 21 panic recover defer
22

#### 23 测试规则和流程

测试函数的基本规则

gotest



## 文章

#### [使用Beego构建完整web项目](https://www.imooc.com/learn/1053)

