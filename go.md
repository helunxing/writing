

## [Go语言从入门到实战](https://time.geekbang.org/course/intro/160)

#### 04 

应用入口文件名不一定是main.go， 必须package main、 func main。 

main函数不支持返回值， 使用os.exit()返回。 

main函数不支持参数传入， 使用os. Args读取参数

#### 05

测试程序格式： **源码文件**以_test结尾， 测试方法以Test开头： func TestXXX(t *testing. T){…}

大写开头包外可访问。 

#### 06

类型间， 类型与其别名间不可隐式转换。 

#### 07

数组间可比较。 位操作符 &^ 按位清零。 

#### 12

string类型内容不可更改， len存放的是byte数， 且string可存放任何二进制数据。 占位符"%[下标]x", 数组。 

#### 13

函数多返回值

#### 14

函数不定长， defer延迟执行

#### 15

行为（结构体的方法）定义时参数为结构体地址， 则不会复制， 为结构体本身， 则会复制

#### 16

无继承， 非入侵性实现接口， ducktype方式， 循环依赖， 实现单向

#### 17

重载严格， 不支持lsp， 重载

#### 18

接口最佳实践： 最小接口

#### 19

错误处理最佳实践： 及早失败， 若发生错误则返回错误信息并return， 若没错则继续执行， 避免try的嵌套

#### 20

panic不可恢复错误， 退出前会执行defer内容。 Os.exit不会调用defer， 不输出当前调用栈信息。 recover修复错误。 错误的方法： 只记录， 不做任何恢复。 可能导致系统明明用完资源却继续运行。 不确定时重启也是不错的。 

#### 21

首字母大写表示代表包外可访问。 package可与所在目录不一致。 同一目录go代码的package要一致。 路径的src是自带的， 调用时不用输。 依赖的包的init方法在main执行前都会被执行， 按照包导入的依赖顺序， 每个包， 每个源文件可以有多个init函数。 将依次执行。 可以导入网上的包。 Go get。 GitHub上提交不要有src

#### 22 vendor路径

解决两个问题： 同一环境不同项目无法使用同一包的不同版本； 无法管理包对特定版本的依赖。 

#### 23 协程

初始化栈仅2k， 和内核对象的对应关系是m:n多对多。 go协程处理器P在系统线程M中， 依次运行协程G队列。 守护线程会对P完成协程数计数， 若不动， 则在P任务栈中加入特别标记。 P遇到非内联函数会读到标记， 并将当前协程G放到队尾。 协程G被系统中断（如IO）时， P会将自己移到另一个M中， 继续执行自己的G队列（必须同一进程内的不同线程？ ）。 唤醒时， G会加入某个P的队列， 或者加入全局队列（是否涉及内存数据的复制？ ）。 被中断时， P在寄存器里的运行信息， 也会保存到P对象里， 当再次获得执行机会时， 会恢复现场。 

协程中执行： go关键字空格函数。 注意函数中不应访问非线程安全资源。 方法调用都是值传递。 

#### 24

sync. Mutex 锁 sync. Waitgroup 等待 rwlock读写锁

#### 25

csp并发机制， 实现异步返回。 chan建立channel， 实现两函数通信。 <-向channel传输数据。 ？ 需要再看

#### 26 select多路选择实现超时处理

#### 27 channel的关闭

#### 28 使用channel和select实现关闭多个消费者

#### 29 context结束关联任务

#### 30 sync.once保证只执行一次

#### 31

channel实现得到任意任务完成后得结果， 并使用buffer防止协程泄漏

#### 32

channel csp机制实现得到所有任务完成结果

#### 33 buffered channel实现对象池

#### 34

sync.pool对象缓存 GC即会将其清空 线程安全  ？ 没看懂

#### 35 单元测试

fail t.error不终止, failnow t.fatal终止。 下载后使用断言。 

#### 36 性能测试

Benchmark开头， testing.b

#### 37 BDD面向行为开发

import(."XX")里的点 代表直接调用不用包命

#### 38 反射

获取类型， 获取值， 按名字调用方法 struct tag `json:"name"` namefield.tag.get

#### 39 万能程序

reflect.deepequal Elem() 获取指针指向的值

#### 40 不安全 unsafe

一般用在c程序交互 atomic.storepointer写完后将读指针更改

#### 41 pipe-filter架构

#### 42 微内核模式 ？ 没看懂

#### 43 内置json解析 反射 方便 性能不高

#### 44 easyjson 更高性能的解析

#### 45 HTTP服务

#### 46 restful服务

#### 47 性能分析工具

输出prof文件 go tool分析； http/pprof使用HTTP输出查看即时性能分析

#### 48 性能调优过程演示

#### 49 锁对性能的影响

读写锁rwlock消耗大， sync.map写成本高， concurrentmap读写性能好。 三者的比较。 disruptor高性能数据交换队列。 

#### 50 GC友好的代码： 与javagc机制不同， 但gc友好代码差不多。 

避免内存分配和复制： 

* go全面采用值传递， 复杂对象应当传引用。 

查看gc日志的方法
go test -trace=trace_val.out
内存gc记录

* 初始化至合适大小， 复用内存

#### 51 高效字符串连接： 

占位符替换 >
+= >
byte.buffer 略大于
stringbuilder

#### 52 分布式 高可用 面向错误的设计。 

* 隔离错误， 微服务模式， 降级可用。 
* 隔离与重用， 同样的程序运行多个， 每个只接待较少的上下级。 
* 冗余， 要避免单点失效系统崩溃。 
* 限流

* 慢响应： 应该给阻塞操作加期限
* 错误向依赖的服务传递： 使用断路器， 通常配合服务降级完成

#### 53 面向恢复的设计： 预知所有失败是不可能的。 

健康检查： 注意僵尸进程， 池化资源耗尽， 死锁

未知错误应直接关闭服务， 避免成为僵尸进程

构建可恢复系统： 
拒绝单体系统， 使用微内核系统。 

面向错误和恢复的设计： 依赖服务不可用时， 可以继续存活。 快速启动。 无状态。 

与客户端协商

#### 54 混沌工程： 可控范围内模拟错误， 观察后果， 思考解决方案， 改善系统。 

主机掉线。 不返回。 返回错误。 

原则

开源实现： Netflix。 类spring框架。 

## [Go语言核心36讲](https://time.geekbang.org/column/112)

#### 1 gopath

